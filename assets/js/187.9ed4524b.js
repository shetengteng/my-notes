(window.webpackJsonp=window.webpackJsonp||[]).push([[187],{1120:function(v,_,l){"use strict";l.r(_);var e=l(15),n=Object(e.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("p",[v._v("ES 默认安装后设置的内存是 1GB，对于任何一个现实业务来说，这个设置都太小了。如果是通过解压安装的 ES，则在 ES 安装文件中包含一个 jvm.option 文件，添加如下命令来设置 ES 的堆大小， Xms 表示堆的初始大小， Xmx 表示可分配的最大内存，都是 1GB")]),v._v(" "),l("p",[v._v("确保 Xmx 和 Xms 的大小是相同的，其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源，可以减轻伸缩堆大小带来的压力")]),v._v(" "),l("p",[v._v("假设有一个 64G 内存的机器，按照正常思维思考，可能会认为把 64G 内存都给ES 比较好，但现实是这样吗， 越大越好？虽然内存对 ES 来说是非常重要的，但是答案是否定的！")]),v._v(" "),l("p",[v._v("因为 ES 堆内存的分配需要满足以下两个原则")]),v._v(" "),l("ul",[l("li",[v._v("不要超过物理内存的 50%\n"),l("ul",[l("li",[v._v("Lucene 的设计目的是把底层 OS 里的数据缓存到内存中")]),v._v(" "),l("li",[v._v("Lucene 的段是分别存储到单个文件中的，这些文件都是不会变化的，很利于缓存，同时操作系统也会把这些段文件缓存起来，以便更快的访问")]),v._v(" "),l("li",[v._v("如果设置的堆内存过大， Lucene 可用的内存将会减少，就会严重影响降低 Lucene 的全文本查询性能")])])]),v._v(" "),l("li",[v._v("堆内存的大小最好不要超过 32GB\n"),l("ul",[l("li",[v._v("在 Java 中，所有对象都分配在堆上，然后有一个 Klass Pointer 指针指向它的类元数据。这个指针在 64 位的操作系统上为 64 位， 64 位的操作系统可以使用更多的内存（2^64）。32 位的操作系统的最大寻址空间为 4GB（2^32），但是 64 位的指针意味着更大的浪费，因为指针本身大了。浪费内存不算，更糟糕的是，更大的指针在主内存和缓存器（例如 LLC, L1 等）之间移动数据的时候，会占用更多的带宽")])])])]),v._v(" "),l("p",[v._v("最终都会采用 31 G 设置")]),v._v(" "),l("ul",[l("li",[v._v("-Xms 31g")]),v._v(" "),l("li",[v._v("-Xmx 31g")])]),v._v(" "),l("p",[v._v("假设有个机器有 128 GB 的内存，可以创建两个节点，每个节点内存分配不超过 32 GB")]),v._v(" "),l("ul",[l("li",[v._v("不超过 64 GB 内存给 ES 的堆内存")]),v._v(" "),l("li",[v._v("剩下的超过 64 GB 的内存给 Lucene")])])])}),[],!1,null,null,null);_.default=n.exports}}]);