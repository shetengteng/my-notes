(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{1221:function(t,a,r){"use strict";r.r(a);var s=r(15),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),s("p",[t._v("kafka传统定义")]),t._v(" "),s("ul",[s("li",[t._v("Kafka是一个"),s("strong",[t._v("分布式")]),t._v("的基于"),s("strong",[t._v("发布/订阅模式")]),t._v("的"),s("strong",[t._v("消息队列")]),t._v("（Message Queue），主要应用于大数据实时处理领域")])]),t._v(" "),s("p",[t._v("发布/订阅")]),t._v(" "),s("ul",[s("li",[t._v("消息的发布者不会将消息直接发送给特定的订阅者，而是将"),s("strong",[t._v("发布的消息分为不同的类别")]),t._v("，订阅者"),s("strong",[t._v("只接收感兴趣的消息")]),t._v(" "),s("ul",[s("li",[t._v("订阅者可以自己控制消费的速率")])])])]),t._v(" "),s("p",[t._v("kafka最新定义")]),t._v(" "),s("ul",[s("li",[t._v("Kafka是 一个开源的"),s("strong",[t._v("分布式事件流平台")]),t._v(" （Event Streaming Platform），被数千家公司用于"),s("strong",[t._v("高性能数据管道、流分析、数据集成和关键任务应用")])])]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:r(755)}}),t._v(" "),s("h2",{attrs:{id:"消息队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),s("p",[t._v("目前企业中比较常见的消息队列产品主要有 Kafka、ActiveMQ 、RabbitMQ 、 RocketMQ 等")]),t._v(" "),s("ul",[s("li",[t._v("在大数据场景主要采用 Kafka 作为消息队列")]),t._v(" "),s("li",[t._v("在 JavaEE 开发中主要采用 ActiveMQ、 RabbitMQ、RocketMQ")])]),t._v(" "),s("h3",{attrs:{id:"应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),s("p",[t._v("要应用场景包括")]),t._v(" "),s("h4",{attrs:{id:"缓存-消峰"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存-消峰"}},[t._v("#")]),t._v(" 缓存/消峰")]),t._v(" "),s("blockquote",[s("p",[t._v("有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况")])]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:r(756)}}),t._v(" "),s("h4",{attrs:{id:"解耦"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解耦"}},[t._v("#")]),t._v(" 解耦")]),t._v(" "),s("blockquote",[s("p",[t._v("允许独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束")])]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:r(757)}}),t._v(" "),s("h4",{attrs:{id:"异步通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步通信"}},[t._v("#")]),t._v(" 异步通信")]),t._v(" "),s("blockquote",[s("p",[t._v("允许用户把一个消息放入队列，但并不立即处理它，然后"),s("strong",[t._v("在需要的时候再去处理它们")])])]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:r(758)}}),t._v(" "),s("h3",{attrs:{id:"两种模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两种模式"}},[t._v("#")]),t._v(" 两种模式")]),t._v(" "),s("h4",{attrs:{id:"点对点模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#点对点模式"}},[t._v("#")]),t._v(" 点对点模式")]),t._v(" "),s("p",[t._v("消费者主动拉取数据，消息收到后清除消息")]),t._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:r(759)}}),t._v(" "),s("h4",{attrs:{id:"发布订阅模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式"}},[t._v("#")]),t._v(" 发布订阅模式")]),t._v(" "),s("p",[t._v("有多个topic主题（浏览，点赞，收藏，评论等）\n消费者消费数据之后，不删除数据（实际使用中，可配置数据的存储周期）\n每个消费者相互独立，都可以消费到数据")]),t._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:r(760)}}),t._v(" "),s("h2",{attrs:{id:"kafka基础架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka基础架构"}},[t._v("#")]),t._v(" kafka基础架构")]),t._v(" "),s("p",[t._v("有100T的数据产生，而正常的服务器存储在8T~96T之间，一台服务器不能存储那么多的数据，需要多台机器进行存储，如何处理？")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:r(761)}}),t._v(" "),s("ul",[s("li",[t._v("解决：为了方便扩展，提高吞吐量，一个topic可以分为多个partition放置在多台服务器进行存储")])]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:r(762)}}),t._v(" "),s("ul",[s("li",[t._v("配合分区的设计，提出消费者组概念，组内每个消费者并行消费\n"),s("ul",[s("li",[t._v("注意：一个分区的数据只能分配给一个消费者消费")])])])]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:r(763)}}),t._v(" "),s("ul",[s("li",[t._v("为了提高可用性，为每个partition增加若干副本，类似NameNode HA\n"),s("ul",[s("li",[t._v("kafka的副本分为Leader和Follower\n"),s("ul",[s("li",[t._v("注意：生产者和消费者只与Leader的副本进行生产和消费，与Follower副本无关，不进行任何操作；当Leader宕机之后，Follower有条件会成为Leader")])])]),t._v(" "),s("li",[t._v("ZK中记录了leader，Kafka2.8.0以后可以配置不使用ZK，ZK中记录了如下内容\n"),s("ul",[s("li",[t._v("/brokers/ids/[0,1,2] 表示哪些服务器上线")]),t._v(" "),s("li",[t._v("/brokers/topics/first/partitions/0/state 表示每个分区，哪个是leader，以及ISR成员有哪些，在生成与消费的时候直接找leader处理\n"),s("ul",[s("li",[t._v('"leader":0,"isr":[0,2]')])])])])])])])]),t._v(" "),s("p",[t._v("// todo xxx")]),t._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:r(764)}}),t._v(" "),s("h3",{attrs:{id:"producer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#producer"}},[t._v("#")]),t._v(" producer")]),t._v(" "),s("p",[t._v("消息生产者，向Kafka broker发送消息的客户端，使用java编写")]),t._v(" "),s("h3",{attrs:{id:"consumer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#consumer"}},[t._v("#")]),t._v(" consumer")]),t._v(" "),s("p",[t._v("消息消费者，向Kafka broker 拉取消息的客户端，使用java编写")]),t._v(" "),s("h3",{attrs:{id:"consumer-group"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#consumer-group"}},[t._v("#")]),t._v(" consumer group")]),t._v(" "),s("p",[t._v("消费组，由多个consumer组成\n消费组内每个消费者负责消费不同分区的数据，"),s("strong",[t._v("一个分区只能由一个消费组内消费者消费")]),t._v("\n消费组之间互不影响")]),t._v(" "),s("p",[t._v("所有消费者都属于某个消费组，"),s("strong",[t._v("消费者组是逻辑上的一个订阅者")])]),t._v(" "),s("h3",{attrs:{id:"broker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#broker"}},[t._v("#")]),t._v(" broker")]),t._v(" "),s("p",[t._v("一台kafka服务器就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic，使用scala编写")]),t._v(" "),s("h3",{attrs:{id:"topic"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#topic"}},[t._v("#")]),t._v(" topic")]),t._v(" "),s("p",[t._v("可以理解为一个队列，"),s("strong",[t._v("消费者和生产者面向的都是一个topic")])]),t._v(" "),s("h3",{attrs:{id:"partition"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#partition"}},[t._v("#")]),t._v(" partition")]),t._v(" "),s("p",[t._v("为了实现扩展性，一个非常大的topic可以分布到多个broker中，"),s("strong",[t._v("一台topic可以分为多个partition")]),t._v("，每个partition是一个"),s("strong",[t._v("有序队列")])]),t._v(" "),s("h3",{attrs:{id:"replica"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#replica"}},[t._v("#")]),t._v(" replica")]),t._v(" "),s("p",[t._v("副本，一个topic的每个分区都有若干个副本，一个"),s("strong",[t._v("Leader")]),t._v("和若干个"),s("strong",[t._v("Follower")])]),t._v(" "),s("h3",{attrs:{id:"leader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#leader"}},[t._v("#")]),t._v(" leader")]),t._v(" "),s("p",[t._v("每个分区多个副本的主副本，生产者发送数据的对象，消费者消费数据的对象都是leader")]),t._v(" "),s("h3",{attrs:{id:"follower"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#follower"}},[t._v("#")]),t._v(" follower")]),t._v(" "),s("p",[t._v("每个分区多个副本中的从副本，实时从leader中同步数据，保持和leader数据的同步，leader发生故障时，某个follower会成为新的leader")])])}),[],!1,null,null,null);a.default=e.exports},755:function(t,a,r){t.exports=r.p+"assets/img/kafka.c4387a6a.png"},756:function(t,a,r){t.exports=r.p+"assets/img/peak.9e71d919.png"},757:function(t,a,r){t.exports=r.p+"assets/img/decoupling.713b4623.png"},758:function(t,a,r){t.exports=r.p+"assets/img/async.4b2bceca.png"},759:function(t,a,r){t.exports=r.p+"assets/img/p2p.6bc37dec.png"},760:function(t,a,r){t.exports=r.p+"assets/img/topic.66c0464d.png"},761:function(t,a,r){t.exports=r.p+"assets/img/structure1.4277260e.png"},762:function(t,a,r){t.exports=r.p+"assets/img/structure2.e317b46c.png"},763:function(t,a,r){t.exports=r.p+"assets/img/structure3.539cf1fb.png"},764:function(t,a,r){t.exports=r.p+"assets/img/structure.666b83ce.png"}}]);