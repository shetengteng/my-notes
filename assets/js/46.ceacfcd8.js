(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{1105:function(_,v,t){"use strict";t.r(v);var d=t(15),e=Object(d.a)({},(function(){var _=this,v=_.$createElement,d=_._self._c||v;return d("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[d("p",[_._v("分片是Elasticsearch最小的工作单元。但是究竟什么是一个分片，它是如何工作的？")]),_._v(" "),d("ul",[d("li",[_._v("传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值的能力。最好的支持是一个字段多个值需求的数据结构是"),d("strong",[_._v("倒排索引")])])]),_._v(" "),d("h2",{attrs:{id:"倒排索引原理"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#倒排索引原理"}},[_._v("#")]),_._v(" 倒排索引原理")]),_._v(" "),d("p",[_._v("Elasticsearch 使用一种称为倒排索引的结构，它适用于快速的全文搜索，有倒排索引，肯定会对应有正向索引正向索引（forward index），反向索引（inverted index 即倒排索引）")]),_._v(" "),d("h3",{attrs:{id:"正向索引"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#正向索引"}},[_._v("#")]),_._v(" 正向索引")]),_._v(" "),d("p",[_._v("搜索引擎会将待搜索的文件都对应一个文件 ID，搜索时将这个ID 和搜索关键字进行对应，形成 K-V 对，然后对关键字进行统计计数")]),_._v(" "),d("img",{staticStyle:{zoom:"67%"},attrs:{src:t(700)}}),_._v(" "),d("h3",{attrs:{id:"倒排索引"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#倒排索引"}},[_._v("#")]),_._v(" 倒排索引")]),_._v(" "),d("p",[_._v("互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足实时返回排名结果的要求。所以，搜索引擎会将"),d("strong",[_._v("正向索引重新构建为倒排索引")]),_._v("，把文件ID对应到关键词的映射转换为关键词到文件ID的映射，每个关键词都对应着一系列的文件，这些文件中都出现这个关键词")]),_._v(" "),d("img",{staticStyle:{zoom:"67%"},attrs:{src:t(701)}}),_._v(" "),d("p",[_._v("一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表")]),_._v(" "),d("h4",{attrs:{id:"示例"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[_._v("#")]),_._v(" 示例")]),_._v(" "),d("ul",[d("li",[_._v("如，假设有两个文档，每个文档的 content 域包含如下内容\n"),d("ul",[d("li",[_._v("The quick brown fox jumped over the lazy dog")]),_._v(" "),d("li",[_._v("Quick brown foxes leap over lazy dogs in summer")])])]),_._v(" "),d("li",[_._v("为了创建倒排索引首先将每个文档的 content 域拆分成单独的词（称为词条或 tokens ），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示")])]),_._v(" "),d("table",[d("thead",[d("tr",[d("th",[_._v("Term")]),_._v(" "),d("th",[_._v("Doc_1")]),_._v(" "),d("th",[_._v("Doc_2")])])]),_._v(" "),d("tbody",[d("tr",[d("td",[_._v("Quick")]),_._v(" "),d("td"),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("The")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td")]),_._v(" "),d("tr",[d("td",[_._v("brown")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("dog")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td")]),_._v(" "),d("tr",[d("td",[_._v("dogs")]),_._v(" "),d("td"),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("fox")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td")]),_._v(" "),d("tr",[d("td",[_._v("foxes")]),_._v(" "),d("td"),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("in")]),_._v(" "),d("td"),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("jumped")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td")]),_._v(" "),d("tr",[d("td",[_._v("lazy")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("leap")]),_._v(" "),d("td"),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("over")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("quick")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td")]),_._v(" "),d("tr",[d("td",[_._v("summer")]),_._v(" "),d("td"),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("the")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td")])])]),_._v(" "),d("ul",[d("li",[_._v("现在，如果想搜索 quick brown ，只需要查找包含每个词条的文档")])]),_._v(" "),d("table",[d("thead",[d("tr",[d("th",[_._v("Term")]),_._v(" "),d("th",[_._v("Doc_1")]),_._v(" "),d("th",[_._v("Doc_2")])])]),_._v(" "),d("tbody",[d("tr",[d("td",[_._v("Quick")]),_._v(" "),d("td"),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("brown")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[d("strong",[_._v("Total")])]),_._v(" "),d("td",[_._v("1")]),_._v(" "),d("td",[_._v("2")])])])]),_._v(" "),d("ul",[d("li",[d("p",[_._v("两个文档都匹配，但是Doc_2比Doc_1匹配度更高。如果使用仅计算匹配词条数量的简单相似性算法，那对于查询的相关性来讲，Doc_2比Doc_1更佳")])]),_._v(" "),d("li",[d("p",[_._v("但目前的倒排索引有一些问题")]),_._v(" "),d("ul",[d("li",[d("p",[d("code",[_._v("Quick")]),_._v("和"),d("code",[_._v("quick")]),_._v("以独立的词条出现，然而用户可能认为它们是相同的词")])]),_._v(" "),d("li",[d("p",[d("code",[_._v("fox")]),_._v("和"),d("code",[_._v("foxes")]),_._v("非常相似，就像"),d("code",[_._v("dog")]),_._v("和"),d("code",[_._v("dogs")]),_._v("，它们有相同的词根")])]),_._v(" "),d("li",[d("p",[d("code",[_._v("jumped")]),_._v("和"),d("code",[_._v("leap")]),_._v("，尽管没有相同的词根，但它们的意思很相近，它们是同义词")])])])]),_._v(" "),d("li",[d("p",[_._v("使用前面的索引搜索"),d("code",[_._v("+Quick")]),_._v("和"),d("code",[_._v("+fox")]),_._v("不会得到任何匹配文档")]),_._v(" "),d("ul",[d("li",[_._v("＋前缀表明这个词必须存在")]),_._v(" "),d("li",[_._v("只有同时出现Quick和fox 的文档才满足这个查询条件，但一个文档包含quick fox ，另一个文档包含Quick foxes")])])]),_._v(" "),d("li",[d("p",[_._v("用户可以合理的期望两个文档与查询匹配")]),_._v(" "),d("ul",[d("li",[_._v("若将词条规范为标准模式，那么可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档，如\n"),d("ul",[d("li",[_._v("Quick可以小写化为quick")]),_._v(" "),d("li",[_._v("foxes可以词干提取变为词根的格式为fox")]),_._v(" "),d("li",[_._v("dogs可以为提取为dog")]),_._v(" "),d("li",[_._v("jumped和leap是同义词，可索引为相同的单词jump")])])]),_._v(" "),d("li",[_._v("现在索引表转换成如下内容")])]),_._v(" "),d("table",[d("thead",[d("tr",[d("th",[_._v("Term")]),_._v(" "),d("th",[_._v("Doc_1")]),_._v(" "),d("th",[_._v("Doc_2")])])]),_._v(" "),d("tbody",[d("tr",[d("td",[_._v("brown")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("dog")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("fox")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("in")]),_._v(" "),d("td"),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("jump")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("lazy")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("over")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("quick")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("summer")]),_._v(" "),d("td"),_._v(" "),d("td",[_._v("x")])]),_._v(" "),d("tr",[d("td",[_._v("the")]),_._v(" "),d("td",[_._v("x")]),_._v(" "),d("td",[_._v("x")])])])]),_._v(" "),d("ul",[d("li",[_._v("但搜索"),d("code",[_._v("+Quick")]),_._v(" "),d("code",[_._v("+fox")]),_._v(" 仍然 会失败，因为在索引中，已经没有"),d("code",[_._v("Quick")]),_._v("了。但如果对搜索的字符串使用与 content 域相同的标准化规则，会变成查询"),d("code",[_._v("+quick")]),_._v(" "),d("code",[_._v("+fox")]),_._v("，这样两个文档都会匹配，分词和标准化的过程称为"),d("strong",[_._v("分析")]),_._v(" "),d("ul",[d("li",[_._v("只能搜索在索引中出现的词条，所以索引文本和查询字符串必须"),d("strong",[_._v("标准化为相同的格式")])])])])])])])])}),[],!1,null,null,null);v.default=e.exports},700:function(_,v,t){_.exports=t.p+"assets/img/inverted-index.7e62dc8f.png"},701:function(_,v,t){_.exports=t.p+"assets/img/inverted-index2.e8459c98.png"}}]);