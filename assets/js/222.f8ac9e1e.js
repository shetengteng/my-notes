(window.webpackJsonp=window.webpackJsonp||[]).push([[222],{1285:function(t,v,_){"use strict";_.r(v);var e=_(15),d=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("blockquote",[_("p",[t._v("关于Broker有如下的主要参数")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("参数")]),t._v(" "),_("th",[t._v("描述")]),t._v(" "),_("th",[t._v("默认值")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("replica.lag.time.max.ms")]),t._v(" "),_("td",[t._v("ISR 中，如果 Follower 长时间未向 Leader 发送通信请求或同步数据，则该 Follower 将被踢出 ISR")]),t._v(" "),_("td",[t._v("30s")])]),t._v(" "),_("tr",[_("td",[t._v("auto.leader.rebalance.enable")]),t._v(" "),_("td",[t._v("自动 Leader Partition 平衡")]),t._v(" "),_("td",[t._v("true")])]),t._v(" "),_("tr",[_("td",[t._v("leader.imbalance.per.broker.percentage")]),t._v(" "),_("td",[t._v("每个 broker 允许的不平衡的 leader的比率。如果每个 broker 超过了这个值，控制器会触发 leader的平衡")]),t._v(" "),_("td",[t._v("10%")])]),t._v(" "),_("tr",[_("td",[t._v("leader.imbalance.check.interval.seconds")]),t._v(" "),_("td",[t._v("检查 leader 负载是否平衡的间隔时间")]),t._v(" "),_("td",[t._v("300s")])]),t._v(" "),_("tr",[_("td",[t._v("log.segment.bytes")]),t._v(" "),_("td",[t._v("Kafka 中 log 日志是分成一块块存储的，此配置是指 log日志划分成块segment的大小")]),t._v(" "),_("td",[t._v("1G")])]),t._v(" "),_("tr",[_("td",[t._v("log.index.interval.bytes")]),t._v(" "),_("td",[t._v("kafka 里面每当写入了 4kb 大小的日志（.log），然后就往 index文件里面记录一个索引")]),t._v(" "),_("td",[t._v("4Kb")])]),t._v(" "),_("tr",[_("td",[t._v("log.retention.hours")]),t._v(" "),_("td",[t._v("Kafka 中数据保存的时间")]),t._v(" "),_("td",[t._v("7天")])]),t._v(" "),_("tr",[_("td",[t._v("log.retention.minutes")]),t._v(" "),_("td",[t._v("Kafka 中数据保存的时间，分钟级别")]),t._v(" "),_("td",[t._v("默认关闭")])]),t._v(" "),_("tr",[_("td",[t._v("log.retention.ms")]),t._v(" "),_("td",[t._v("Kafka 中数据保存的时间，毫秒级别")]),t._v(" "),_("td",[t._v("默认关闭")])]),t._v(" "),_("tr",[_("td",[t._v("log.retention.check.interval.ms")]),t._v(" "),_("td",[t._v("检查数据是否保存超时的间隔")]),t._v(" "),_("td",[t._v("5min")])]),t._v(" "),_("tr",[_("td",[t._v("log.retention.bytes")]),t._v(" "),_("td",[t._v("超过设置的所有日志总大小，删除最早的segment")]),t._v(" "),_("td",[t._v("默认值-1，表示无穷大")])]),t._v(" "),_("tr",[_("td",[t._v("log.cleanup.policy")]),t._v(" "),_("td",[t._v("表示所有数据启用删除策略；如果设置值为 compact，表示所有数据启用压缩策略")]),t._v(" "),_("td",[t._v("delete")])]),t._v(" "),_("tr",[_("td",[t._v("num.io.threads")]),t._v(" "),_("td",[t._v("负责写磁盘的线程数。整个参数值要占总核数的 50%")]),t._v(" "),_("td",[t._v("8")])]),t._v(" "),_("tr",[_("td",[t._v("num.replica.fetchers")]),t._v(" "),_("td",[t._v("副本拉取线程数，这个参数占总核数的50%的1/3")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("num.network.threads")]),t._v(" "),_("td",[t._v("数据传输线程数，这个参数占总核数的50%的2/3")]),t._v(" "),_("td",[t._v("3")])]),t._v(" "),_("tr",[_("td",[t._v("log.flush.interval.messages")]),t._v(" "),_("td",[t._v("强制页缓存刷写到磁盘的条数；一般不建议修改，交给系统自己管理")]),t._v(" "),_("td",[t._v("默认是 long 的最大值，9223372036854775807")])]),t._v(" "),_("tr",[_("td",[t._v("log.flush.interval.ms")]),t._v(" "),_("td",[t._v("每隔多久，刷数据到磁盘；一般不建议修改，交给系统自己管理")]),t._v(" "),_("td",[t._v("默认是 null")])]),t._v(" "),_("tr",[_("td"),t._v(" "),_("td"),t._v(" "),_("td")])])])])}),[],!1,null,null,null);v.default=d.exports}}]);