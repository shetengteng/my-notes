(window.webpackJsonp=window.webpackJsonp||[]).push([[213],{1197:function(t,v,_){"use strict";_.r(v);var a=_(15),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),_("ul",[_("li",[t._v("Spring Cache 是一个非常优秀的缓存组件")]),t._v(" "),_("li",[t._v("提供了类似于@Transactional注解事务的注解Cache支持")]),t._v(" "),_("li",[t._v("提供了Cache抽象，方便切换各种底层Cache\n"),_("ul",[_("li",[t._v("如：redis")])])])]),t._v(" "),_("h3",{attrs:{id:"好处"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#好处"}},[t._v("#")]),t._v(" 好处")]),t._v(" "),_("ul",[_("li",[t._v("提供基本的Cache抽象，方便切换各种底层Cache")]),t._v(" "),_("li",[t._v("通过注解Cache可以实现类似于事务一样，缓存逻辑透明的应用到我们的业务代码上，且只需要更少的代码就可以完成")]),t._v(" "),_("li",[t._v("提供事务回滚时也自动回滚缓存")]),t._v(" "),_("li",[t._v("支持比较复杂的缓存逻辑")])]),t._v(" "),_("h2",{attrs:{id:"常用缓存注解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用缓存注解"}},[t._v("#")]),t._v(" 常用缓存注解")]),t._v(" "),_("h3",{attrs:{id:"查询-cacheable"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#查询-cacheable"}},[t._v("#")]),t._v(" 查询@Cacheable")]),t._v(" "),_("ul",[_("li",[t._v("根据方法对其返回结果进行缓存，下次请求时\n"),_("ul",[_("li",[t._v("如果缓存存在，则直接读取缓存数据返回")]),t._v(" "),_("li",[t._v("如果缓存不存在，则执行方法，并把返回的结果存入缓存中")])])]),t._v(" "),_("li",[t._v("一般用在查询方法上")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("属性/方法名")]),t._v(" "),_("th",[t._v("解释")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("value")]),t._v(" "),_("td",[t._v("缓存名，必填，它指定了你的缓存存放在哪块命名空间")])]),t._v(" "),_("tr",[_("td",[t._v("cacheNames")]),t._v(" "),_("td",[t._v("与 value 差不多，二选一即可")])]),t._v(" "),_("tr",[_("td",[t._v("key")]),t._v(" "),_("td",[t._v("可选属性，可以使用 SpEL 标签自定义缓存的key")])])])]),t._v(" "),_("h3",{attrs:{id:"新增-cacheput"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#新增-cacheput"}},[t._v("#")]),t._v(" 新增@CachePut")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库")])]),t._v(" "),_("li",[_("p",[t._v("一般用在新增方法上")])])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("属性/方法名")]),t._v(" "),_("th",[t._v("解释")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("value")]),t._v(" "),_("td",[t._v("缓存名，必填，它指定了你的缓存存放在哪块命名空间")])]),t._v(" "),_("tr",[_("td",[t._v("cacheNames")]),t._v(" "),_("td",[t._v("与 value 差不多，二选一即可")])]),t._v(" "),_("tr",[_("td",[t._v("key")]),t._v(" "),_("td",[t._v("可选属性，可以使用 SpEL 标签自定义缓存的key")])])])]),t._v(" "),_("h3",{attrs:{id:"更新或删除-cacheevict"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#更新或删除-cacheevict"}},[t._v("#")]),t._v(" 更新或删除@CacheEvict")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("使用该注解标志的方法，会清空指定的缓存")])]),t._v(" "),_("li",[_("p",[t._v("一般用在更新或者删除方法上")])])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("属性/方法名")]),t._v(" "),_("th",[t._v("解释")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("value")]),t._v(" "),_("td",[t._v("缓存名，必填，它指定了你的缓存存放在哪块命名空间")])]),t._v(" "),_("tr",[_("td",[t._v("cacheNames")]),t._v(" "),_("td",[t._v("与 value 差不多，二选一即可")])]),t._v(" "),_("tr",[_("td",[t._v("key")]),t._v(" "),_("td",[t._v("可选属性，可以使用 SpEL 标签自定义缓存的key")])]),t._v(" "),_("tr",[_("td",[t._v("allEntries")]),t._v(" "),_("td",[t._v("是否清空所有缓存，默认为  false。如果指定为 true，则方法调用后将立即清空所有的缓存")])]),t._v(" "),_("tr",[_("td",[t._v("beforeInvocation")]),t._v(" "),_("td",[t._v("是否在方法执行前就清空，默认为  false。如果指定为 true，则在方法执行前就会清空缓存")])])])])])}),[],!1,null,null,null);v.default=e.exports}}]);