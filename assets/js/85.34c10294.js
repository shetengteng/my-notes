(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{1067:function(s,t,e){"use strict";e.r(t);var r=e(15),n=Object(r.a)({},(function(){var s=this,t=s.$createElement,r=s._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[r("img",{staticStyle:{zoom:"80%"},attrs:{src:e(959),alt:"img"}}),s._v(" "),r("p",[s._v("协调节点默认使用文档 ID 参与计算（也支持通过 routing），为路由提供合适的分片")]),s._v(" "),r("ul",[r("li",[s._v("shard = hash(document_id) % (num_of_primary_shards)")])]),s._v(" "),r("p",[s._v("当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory Buffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache")]),s._v(" "),r("ul",[r("li",[s._v("这个从 Memory Buffer 到 Filesystem Cache 的过程就叫做 "),r("strong",[s._v("refresh")])])]),s._v(" "),r("p",[s._v("当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失， ES 是通过 translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystem cache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 "),r("strong",[s._v("flush")])]),s._v(" "),r("p",[s._v("在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync 将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog")]),s._v(" "),r("p",[s._v("flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时")])])}),[],!1,null,null,null);t.default=n.exports},959:function(s,t,e){s.exports=e.p+"assets/img/question1.94707716.png"}}]);